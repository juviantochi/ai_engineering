# RFC – Veefin Signature Authentication Filter (fs-brick-service)
## Status
- [ ] Draft
- [ ] Proposed
- [x] Accepted
- [ ] Rejected
- [ ] Superseded

**Metadata**:
- **RFC #**: LND-4526
- **Repository**: `fs-brick-service`
- **Author(s)**: @JuviantoChi
- **Updated**: 13-Nov-2024
- **Accepted Date**: 13-Nov-2024
- **Decision**: Approach A (Base Class + Multiple Filter Instances)
- **Rationale**: Limited blast radius (1 partner, growing to 2-3) makes strong isolation and defense-in-depth security more valuable than configuration-driven scalability
- **Parent RFC**: [LND-4526](LND-4526-fs-brick-service-updated.md)
- **Purpose**: Architectural alternatives analysis for senior engineering review

---

## Context

This document presents **two implementation approaches** for partner signature authentication in fs-brick-service:

1. **Approach A**: Base class + multiple filter instances (one per partner)
2. **Approach B**: Single filter + neutral x-partner-id header + pluggable validators

Both approaches achieve the same functional goals but differ in architecture, scalability, and maintainability trade-offs.

---

## Proposal

Evaluate **two signature-authentication designs** for LND-4526 based on scalability and maintainability criteria:

**Key Decision Factors**:
- **Scalability**: Ability to add partners with minimal code changes and deployment overhead
- **Maintainability**: Code clarity, testing isolation, and long-term maintainability
- **Operational Simplicity**: Monitoring, debugging, and configuration management complexity

**Approach A** prioritizes complete isolation and defense-in-depth security through separate filter classes per partner, at the cost of @Order management and code duplication.

**Approach B** prioritizes configuration-driven scalability and operational simplicity through a single filter with pluggable validators, trading some isolation for maintainability.

Both approaches are architecturally sound. The choice depends on team priorities: isolation vs. scalability.

---

## Goals

**Objectives**:
- ✅ Support partner signature authentication for Veefin and future partners
- ✅ Clarify architecture trade-offs between isolation-focused and scalability-focused approaches
- ✅ Enable per-partner customization (validation rules, header formats)
- ✅ Ensure security through signature verification and timestamp validation
- ✅ Maintain performance (<2ms overhead per request)
- ✅ Provide clear decision criteria based on scalability and maintainability priorities

**Non-Goals**:
- ❌ Define partner-specific integration contracts (handled by partner API specifications)
- ❌ Implement rate limiting or quota management (separate feature)
- ❌ Design partner onboarding process (operational concern)
- ❌ Specify exact header naming for each partner (partner-negotiated)
- ❌ Build runtime partner management UI (future enhancement)

---

## Prior Art / Alternatives Considered

This section presents detailed analysis of two architectural approaches, their implementations, and trade-offs.

### Approach A: Base Class + Multiple Filter Instances

### Architecture

```
┌────────────────────────────────────────────────────────────┐
│ AbstractPartnerSignatureFilter (Base)                      │
│  - Template method pattern                                 │
│  - Reusable validation logic                               │
│  - Extensible via method overrides                         │
│  - Sets request.setAttribute("partner.authenticated")      │
└────────────────────────────────────────────────────────────┘
           ↑                    ↑                    ↑
           │ extends            │ extends            │ extends
           │                    │                    │
┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
│ VeefinFilter     │  │ PartnerBFilter   │  │ PartnerCFilter   │
│ @Order(3)        │  │ @Order(4)        │  │ @Order(5)        │
│ super("veefin")  │  │ super("partner-b")│  │ super("partner-c")│
└──────────────────┘  └──────────────────┘  └──────────────────┘
                                                     ↓
              ┌─────────────────────────────────────────────┐
              │ PartnerCatchAllFilter                       │
              │ @Order(LOWEST_PRECEDENCE - 10)              │
              │ - Validates partner.authenticated attribute │
              │ - Rejects if protected path && !auth        │
              │ - Dynamically collects all partner patterns │
              └─────────────────────────────────────────────┘
```

### Implementation

**Base Class**:
```java
public abstract class AbstractPartnerSignatureFilter extends OncePerRequestFilter {
    protected final PartnerSignatureConfig config;
    protected final String partnerName;

    protected void doFilterInternal(...) {
        // 1. Extract headers with partner-specific prefix (e.g., "veefin-x-")
        String partnerId = request.getHeader(prefix + "-partner-id");
        String requestId = request.getHeader(prefix + "-request-id");
        String timestamp = request.getHeader(prefix + "-timestamp");
        String signature = request.getHeader(prefix + "-signature");

        // 2. Validate headers, timestamp, signature
        validateHeaders(...);
        validateTimestamp(...);
        verifySignature(...);  // Can be overridden

        // 3. Success - mark authenticated and proceed
        request.setAttribute("partner.authenticated", true);
        request.setAttribute("partner.id", partnerName);
        onSuccess(...);        // Can be overridden
        filterChain.doFilter(request, response);
    }

    protected boolean shouldNotFilter(HttpServletRequest request) {
        // Skip if path doesn't match OR no partner-specific headers present
    }
}
```

**Concrete Filter** :
```java
@Component
@Order(3)
public class VeefinSignatureAuthenticationFilter extends AbstractPartnerSignatureFilter {
    public VeefinSignatureAuthenticationFilter(PartnerSignatureConfig config) {
        super(config, "veefin");  // Maps to config key
    }
}
```

**Configuration**:
```yaml
partner:
  signature:
    partners:
      veefin:
        id: veefin
        secret: ${VEEFIN_PARTNER_SECRET}
        header-prefix: veefin-x          # Partner-specific
        timestamp-tolerance-minutes: 5
        paths:
          - /fs/brick/service/veefin/**
```

**Catch-All Guard Filter**:
```java
@Component
@Order(Ordered.LOWEST_PRECEDENCE - 10)
public class PartnerCatchAllFilter extends OncePerRequestFilter {

    private final AntPathMatcher matcher = new AntPathMatcher();
    private final Set<String> protectedPatterns;

    public PartnerCatchAllFilter(PartnerSignatureConfig config) {
        // Dynamically collect all partner path patterns from YAML at startup
        this.protectedPatterns = config.getPartners().values().stream()
            .flatMap(pc -> pc.getPathPatterns().stream())
            .collect(Collectors.toUnmodifiableSet());
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain chain)
        throws IOException, ServletException {

        String path = request.getRequestURI();

        // Check if path is protected by any partner
        boolean isProtectedPath = protectedPatterns.stream()
            .anyMatch(pattern -> matcher.match(pattern, path));

        // Check if any partner filter authenticated this request
        boolean wasAuthenticated = Boolean.TRUE.equals(
            request.getAttribute("partner.authenticated"));

        if (isProtectedPath && !wasAuthenticated) {
            // Security: Protected endpoint accessed without authentication
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            response.setContentType("application/json");
            response.getWriter().write(
                "{\"code\":\"UNAUTHORIZED\",\"message\":\"Missing partner authentication\"}");
            return;
        }

        chain.doFilter(request, response);
    }
}
```

**Purpose**: Acts as a safety net ensuring no protected endpoint is reachable without authentication, even if partner filters are misconfigured.

**Performance**: Adds ~10-50μs per request (<3% of signature verification time, <0.05% of typical API latency).

---

### Pros

1. **Strong Isolation** ⭐⭐⭐
   - Bug in VeefinFilter doesn't affect PartnerB
   - Each filter can be tested independently
   - Clear ownership and responsibility boundaries

2. **Easy Per-Partner Customization** ⭐⭐⭐
   - Override validation methods without touching shared code
   - Custom error handling per partner
   - Partner-specific logging/monitoring

3. **Clear Debugging** ⭐⭐
   - Spring shows exact filter in stack trace
   - Easy to identify which partner failed
   - Clear filter chain visualization

4. **Flexible Header Naming** ⭐⭐
   - Partner-specific prefixes: `veefin-x-*`, `partner-b-x-*`
   - Prevents header collision on shared endpoints
   - Branding flexibility (partner requirements)

5. **Gradual Rollout** ⭐
   - Enable/disable specific partner via `@ConditionalOnProperty`
   - Easy to remove partner (delete one file)
   - Independent deployment per partner

6. **Template Method Pattern** ⭐
   - Industry-standard extensibility pattern
   - Clear extension points (protected methods)
   - Familiar to Java developers

7. **Defense-in-Depth Security** ⭐⭐⭐
   - Catch-all filter provides security guarantee
   - Prevents authentication bypass if partner filter misconfigured
   - Dynamically updates protected patterns from config
   - Ensures: `protected path && !authenticated = 401` always

---

### Cons

1. **@Order Management Required** ⚠️⚠️⚠️
   - Each partner needs unique `@Order` number
   - Risk of collision if not coordinated
   - Execution order must be manually managed

   ```java
   @Order(3)  VeefinFilter
   @Order(4)  PartnerBFilter      // Manual ordering
   @Order(5)  PartnerCFilter      // Gets tedious with 10+ partners
   ```

2. **Code Duplication** ⚠️⚠️
   - Each partner requires new Java class (even if 5 lines)
   - Repetitive `@Component` + `@Order` + constructor
   - More files to maintain (N partners = N files)

3. **Not Purely Configuration-Driven** ⚠️⚠️
   - Adding partner requires code change + deployment
   - Cannot add partner via config alone
   - Requires Java knowledge (not just YAML)

4. **Testing Overhead** ⚠️
   - Must test each filter class separately
   - Integration tests require all filters
   - More test classes to maintain

5. **Limited Runtime Flexibility** ⚠️
   - Cannot dynamically add/remove partners
   - Requires application restart for new partner
   - Filter chain fixed at startup

6. **Additional Filter Required** ⚠️
   - Need catch-all filter to prevent bypass
   - Adds ~50μs overhead per request (negligible)
   - Must coordinate @Order between partner filters and catch-all

---

## Approach B: Single Filter + Neutral x-partner-id + Pluggable Validators

### Architecture

```
┌────────────────────────────────────────────────────────────┐
│ PartnerSignatureAuthFilter (Single Filter)                 │
│ @Order(3)                                                   │
│                                                             │
│ 1. Read neutral x-partner-id header first                  │
│ 2. Lookup partner config by partnerId                      │
│ 3. Extract remaining headers using partner's prefix        │
│ 4. Delegate validation to partner's validator bean         │
│ 5. Set request.setAttribute("partner.id", ...)             │
└────────────────────────────────────────────────────────────┘
                           ↓ reads from
┌────────────────────────────────────────────────────────────┐
│ PartnerSignatureConfig (Data Only)                         │
│ Map<String, PartnerConfig> partners                        │
│  - veefin: { secret, header-prefix: "veefin-x", ... }      │
│  - partner-b: { secret, header-prefix: "partner-b-x", ... }│
└────────────────────────────────────────────────────────────┘
                           ↓ delegates to
┌────────────────────────────────────────────────────────────┐
│ PartnerSignatureValidator Interface                        │
│  - VeefinSignatureValidator (custom rules)                 │
│  - PartnerBSignatureValidator (custom rules)               │
│  - DefaultSignatureValidator (standard validation)         │
└────────────────────────────────────────────────────────────┘
```

### Implementation

**Single Filter**:
```java
@Component
@Order(3)
public class PartnerSignatureAuthFilter extends OncePerRequestFilter {

    private final PartnerSignatureConfig config;
    private final Map<String, PartnerSignatureValidator> validators;

    public PartnerSignatureAuthFilter(
        PartnerSignatureConfig config,
        List<PartnerSignatureValidator> validatorList) {
        this.config = config;
        // Map validators by partnerId for quick lookup
        this.validators = validatorList.stream()
            .collect(Collectors.toMap(
                PartnerSignatureValidator::getPartnerId,
                Function.identity()
            ));
    }

    @Override
    protected void doFilterInternal(...) {
        // 1. Read neutral x-partner-id header FIRST
        String partnerId = request.getHeader("x-partner-id");

        if (partnerId == null) {
            respondWithError(response, 401, "Missing x-partner-id header");
            return;
        }

        // 2. Lookup partner config
        PartnerConfig partnerConfig = config.getPartners().get(partnerId);
        if (partnerConfig == null) {
            respondWithError(response, 401, "Unknown partner: " + partnerId);
            return;
        }

        // 3. Extract remaining headers using partner's prefix
        String prefix = partnerConfig.getHeaderPrefix();
        String requestId = request.getHeader(prefix + "-request-id");
        String timestamp = request.getHeader(prefix + "-timestamp");
        String signature = request.getHeader(prefix + "-signature");

        // 4. Validate headers presence
        if (requestId == null || timestamp == null || signature == null) {
            respondWithError(response, 401, "Missing required headers");
            return;
        }

        // 5. Get validator (fallback to default if no custom validator)
        PartnerSignatureValidator validator = validators.getOrDefault(
            partnerId,
            validators.get("default")
        );

        // 6. Delegate all validation to validator
        validator.validateTimestamp(timestamp, partnerConfig);
        validator.validateRequestId(requestId, partnerConfig);
        validator.validateSignature(signature, requestId, timestamp,
            request, partnerConfig);

        // 7. Success - set partner context and continue
        request.setAttribute("partner.id", partnerId);
        filterChain.doFilter(request, response);
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();

        // Skip if path doesn't match any partner patterns
        return config.getPartners().values().stream()
            .flatMap(pc -> pc.getPathPatterns().stream())
            .noneMatch(pattern -> pathMatcher.match(pattern, path));
    }
}
```

**Validator Interface**:
```java
public interface PartnerSignatureValidator {
    String getPartnerId();

    void validateTimestamp(String timestamp, PartnerConfig config);
    void validateRequestId(String requestId, PartnerConfig config);
    void validateSignature(String signature, String requestId,
        String timestamp, HttpServletRequest request, PartnerConfig config);
}
```

**Default Validator**:
```java
@Component
public class DefaultSignatureValidator implements PartnerSignatureValidator {

    @Override
    public String getPartnerId() {
        return "default";
    }

    @Override
    public void validateTimestamp(String timestamp, PartnerConfig config) {
        // Standard timestamp validation
        long now = System.currentTimeMillis() / 1000;
        long requestTime = Long.parseLong(timestamp);
        long diff = Math.abs(now - requestTime);

        if (diff > config.getTimestampToleranceMinutes() * 60) {
            throw new AuthException("Timestamp outside tolerance window");
        }
    }

    @Override
    public void validateRequestId(String requestId, PartnerConfig config) {
        // Standard: alphanumeric, 16-32 chars
        if (!requestId.matches("[a-zA-Z0-9]{16,32}")) {
            throw new AuthException("Invalid request-id format");
        }
    }

    @Override
    public void validateSignature(String signature, String requestId,
        String timestamp, HttpServletRequest request, PartnerConfig config) {

        String payload = String.format("%s|%s|%s",
            config.getPartnerId(), requestId, timestamp);

        if (!SignatureUtils.verifyHmac(signature, config.getSecret(), payload)) {
            throw new AuthException("Signature verification failed");
        }
    }
}
```

**Custom Validator Example (Veefin)**:
```java
@Component
public class VeefinSignatureValidator extends DefaultSignatureValidator {

    @Override
    public String getPartnerId() {
        return "veefin";
    }

    @Override
    public void validateRequestId(String requestId, PartnerConfig config) {
        // Veefin-specific: hex-only, exactly 16 chars
        if (!requestId.matches("[a-f0-9]{16}")) {
            throw new AuthException("Veefin request-id must be 16-char hex");
        }
    }

    // Inherits standard timestamp and signature validation from default
}
```

**PartnerConfig (POJO - Just Data)**:
```java
@ConfigurationProperties(prefix = "partner-signature")
public class PartnerSignatureConfig {
    private Map<String, PartnerConfig> partners;

    public static class PartnerConfig {
        private String partnerId;
        private String secret;
        private String headerPrefix;           // Partner-specific: "veefin-x"
        private int timestampToleranceMinutes;
        private List<String> pathPatterns;

        // Just getters/setters, no validation logic
    }
}
```

**Configuration**:
```yaml
partner-signature:
  partners:
    veefin:
      partner-id: veefin
      secret: ${VEEFIN_SIGNATURE_SECRET}
      header-prefix: veefin-x              # Partner-specific prefix
      timestamp-tolerance-minutes: 5
      path-patterns:
        - /fs/brick/service/veefin/**
    partner-b:
      partner-id: partner-b
      secret: ${PARTNERB_SIGNATURE_SECRET}
      header-prefix: partner-b-x           # Different prefix
      timestamp-tolerance-minutes: 3
      path-patterns:
        - /fs/brick/service/partner-b/**
```

**Header Structure**:
```
All partners send:
  x-partner-id: veefin|partner-b|...       # Neutral, required first

Partner-specific headers follow:
  Veefin:
    veefin-x-request-id: abc123...
    veefin-x-timestamp: 1699776000
    veefin-x-signature: dGVzdA==

  Partner B:
    partner-b-x-request-id: 123456...
    partner-b-x-timestamp: 1699776000
    partner-b-x-signature: YWJjZA==
```

---

### Pros

1. **No @Order Collision** ⭐⭐⭐
   - Single filter at `@Order(3)`
   - No coordination needed between partners
   - Scalable to unlimited partners

2. **No Header Detection Loop** ⭐⭐⭐
   - Neutral `x-partner-id` header read first (O(1))
   - No need to loop through partner prefixes
   - More efficient than prefix-based detection

3. **Pluggable Customization** ⭐⭐⭐
   - Validator pattern for per-partner custom rules
   - Clean separation: filter (flow) vs validators (logic)
   - Easy to add custom validation without touching filter

4. **Configuration-Driven Partners** ⭐⭐⭐
   - Add new partner = add YAML block + optional validator bean
   - Standard validation? Just YAML config needed
   - Custom validation? Add validator bean

5. **Partner-Specific Headers** ⭐⭐
   - Each partner has branded headers: `veefin-x-*`, `partner-b-x-*`
   - No header collision on shared endpoints
   - Branding flexibility (partner requirements)

6. **Simpler Codebase** ⭐⭐⭐
   - One filter class instead of N classes
   - No catch-all filter needed
   - PartnerConfig is just data (POJO)
   - Validators contain logic, clean separation of concerns

7. **Easier Monitoring** ⭐⭐
   - Single filter to instrument
   - Centralized metrics/logging with `partnerId` tag
   - Consistent monitoring across all partners

8. **Best of Both Worlds** ⭐⭐⭐
   - Config-driven like single filter approach
   - Partner-specific headers like multi-filter approach
   - Customization via validators (not if-else)
   - Efficient partner detection (no loop)

---

### Cons

1. **Single Point of Failure in Filter** ⚠️⚠️
   - Bug in filter flow affects ALL partners
   - Filter logic shared across all partners
   - Mitigated: Validators isolate custom logic per partner

2. **Additional Abstraction Layer** ⚠️⚠️
   - Requires validator interface and implementations
   - More abstraction than Approach A's direct inheritance
   - Trade-off: More flexible but slightly more complex

3. **Requires Neutral Header** ⚠️
   - Partners must send `x-partner-id` header
   - Additional header vs prefix-only detection
   - Trade-off: Simpler detection but one more header

4. **Harder Debugging Than Approach A** ⚠️⚠️
   - Single filter in stack trace (not per-partner filter)
   - Need to check logs to see which partner/validator failed
   - Less clear than Approach A's per-filter traces
   - Mitigated: Validator pattern provides some isolation

5. **Testing More Complex Than A** ⚠️
   - Must test filter + validators together
   - Cannot test complete flow in pure isolation like Approach A
   - More test setup coordination required
   - Mitigated: Can test validators independently

6. **No Defense-in-Depth** ⚠️
   - No catch-all filter safety net
   - Single validation point
   - Must ensure filter logic is robust

---

## Detailed Comparison

### 1. Scalability

| Aspect | Approach A (Multiple Filters) | Approach B (Single Filter + Validators) |
|--------|-------------------------------|----------------------------------------|
| **Adding 10th Partner** | Create 10th Java class with @Order(12) | Add YAML block + optional validator bean |
| **@Order Management** | Manual coordination required | No management needed |
| **Code Files** | 10 filter classes + base + catch-all | 1 filter + N validators (only if custom rules) |
| **Deployment** | Required for each partner | Config-only (standard validation) or single deploy (custom validator) |
| **Runtime Flexibility** | Fixed at startup | Dynamic via config + validator registry |
| **Partner Detection** | Path-based (shouldNotFilter) | Header-based (x-partner-id, O(1)) |

---

### 2. Maintainability

| Aspect | Approach A | Approach B |
|--------|------------|------------|
| **Bug Fix Impact** | Fix base class, all partners inherit | Fix filter (flow) or validator (logic) |
| **Partner Isolation** | ✅ Bug in one filter doesn't affect others | ⚠️ Filter shared, but validators isolated |
| **Code Clarity** | ✅ Clear separation per partner | ✅ Clear separation: filter (flow) vs validators (logic) |
| **Test Isolation** | ✅ Test each filter independently | ⚠️ Filter + validators, but validators testable independently |
| **Debugging** | ✅ Clear stack trace per filter | ⚠️ Single filter trace, validator context in logs |
| **Customization** | ✅ Override methods per partner | ✅ Implement validator per partner |

---

### 3. Customization Needs

**Scenario**: Veefin requires hex-only request-ids, Partner B requires numeric-only

#### Approach A:
```java
// VeefinFilter.java - Clean override
@Override
protected void validateRequestId(String requestId) {
    super.validateRequestId(requestId);  // Base validation

    if (!requestId.matches("[a-f0-9]{16}")) {
        throw new AuthException("Veefin request-id must be hex");
    }
}

// PartnerBFilter.java - Separate override
@Override
protected void validateRequestId(String requestId) {
    super.validateRequestId(requestId);  // Base validation

    if (!requestId.matches("\\d{16}")) {
        throw new AuthException("Partner B request-id must be numeric");
    }
}
```

#### Approach B:
```java
// VeefinSignatureValidator.java - Custom validator
@Component
public class VeefinSignatureValidator extends DefaultSignatureValidator {

    @Override
    public String getPartnerId() {
        return "veefin";
    }

    @Override
    public void validateRequestId(String requestId, PartnerConfig config) {
        // Veefin-specific: hex-only, exactly 16 chars
        if (!requestId.matches("[a-f0-9]{16}")) {
            throw new AuthException("Veefin request-id must be 16-char hex");
        }
    }

    // Inherits standard timestamp and signature validation from default
}

// PartnerBSignatureValidator.java - Custom validator
@Component
public class PartnerBSignatureValidator extends DefaultSignatureValidator {

    @Override
    public String getPartnerId() {
        return "partner-b";
    }

    @Override
    public void validateRequestId(String requestId, PartnerConfig config) {
        // Partner B specific: numeric-only, exactly 16 chars
        if (!requestId.matches("\\d{16}")) {
            throw new AuthException("Partner B request-id must be numeric");
        }
    }

    // Inherits standard timestamp and signature validation from default
}
```

---

### 4. Header Naming Strategy

#### Approach A (Partner-Specific Prefixes Only):
```
Veefin Headers:
  veefin-x-partner-id: veefin
  veefin-x-request-id: abc123...
  veefin-x-timestamp: 1699776000
  veefin-x-signature: dGVzdA==

Partner B Headers:
  partner-b-x-partner-id: partner-b
  partner-b-x-request-id: 123456...
  partner-b-x-timestamp: 1699776000
  partner-b-x-signature: YWJjZA==
```

**Pros**:
- ✅ No header collision (different prefixes)
- ✅ Partner branding in headers
- ✅ Clear which partner is calling

**Cons**:
- ⚠️ Each partner has different header names to remember
- ⚠️ Not standardized across partners

#### Approach B (Neutral x-partner-id + Partner Prefixes):
```
All partners send neutral header first:
  x-partner-id: veefin|partner-b|...       # Read first for O(1) detection

Then partner-specific headers:
  Veefin:
    veefin-x-request-id: abc123...
    veefin-x-timestamp: 1699776000
    veefin-x-signature: dGVzdA==

  Partner B:
    partner-b-x-request-id: 123456...
    partner-b-x-timestamp: 1699776000
    partner-b-x-signature: YWJjZA==
```

**Pros**:
- ✅ No header collision (different prefixes for request/timestamp/signature)
- ✅ Partner branding in headers
- ✅ Clear which partner is calling
- ✅ O(1) partner detection (no loop)
- ✅ Config-driven (add partner via YAML + optional validator)

**Cons**:
- ⚠️ One additional header (x-partner-id)
- ⚠️ Each partner still has different prefixes to remember

---

### 5. Security Considerations

| Aspect | Approach A | Approach B |
|--------|------------|------------|
| **Signature Payload** | `partnerId\|requestId\|timestamp` | `partnerId\|requestId\|timestamp` |
| **Replay Protection** | Timestamp only | Timestamp only |
| **Secret Isolation** | Each filter has own secret reference | All secrets in single config map |
| **Blast Radius** | Bug affects one partner | Filter bug affects all, validator bug affects one |
| **Bypass Protection** | Catch-all filter (defense-in-depth) | Built-in (single validation point) |
| **Customization Isolation** | Per-filter override (full isolation) | Per-validator (logic isolation, shared filter) |

---

### 6. Performance

Both approaches have **negligible performance difference**:

- HMAC-SHA256 computation: ~1-2ms
- Header extraction: ~0.1ms
- Config lookup: ~0.1ms
- Validator delegation: ~0.01ms

**Key Differences**:
- **Approach A**: Spring evaluates N filters + catch-all sequentially (shouldNotFilter check ~10μs each)
- **Approach B**: Single filter, one shouldNotFilter check, O(1) partner detection via x-partner-id

**Approach A - Multiple filters overhead**: ~10-50μs (for 10 partners + catch-all)
- Spring evaluates each filter's shouldNotFilter
- Only matching filter executes validation
- Catch-all always executes

**Approach B - Single filter overhead**: ~5-10μs
- Single shouldNotFilter evaluation
- Direct partner lookup by x-partner-id (O(1))
- Validator delegation adds negligible overhead

**Comparison**:
- Signature verification: ~1,000-2,000μs (1-2ms)
- Filter overhead difference: ~5-40μs between approaches
- Typical API request: 100,000-200,000μs (100-200ms)
- Performance difference: <0.05% of total request time
- **Conclusion**: Performance difference is negligible, choose based on architecture preferences

---

## Decision Matrix

### Use Approach A (Multiple Filters) When:

✅ **Strong isolation is critical**
- Regulatory requirements for partner separation
- High-risk partners need complete isolation
- Independent testing and deployment per partner required

✅ **Defense-in-depth security preferred**
- Catch-all filter provides additional safety layer
- Prevents accidental bypass if partner filter misconfigured
- Guaranteed: `protected path && !authenticated = 401`

✅ **Small number of partners** (1-3)
- @Order management is manageable
- Code duplication is acceptable
- Clear separation outweighs configuration simplicity

✅ **Template method pattern familiarity**
- Team familiar with inheritance-based extension
- Prefer override methods over composition
- Clear extension points via protected methods

---

### Use Approach B (Single Filter + Validators) When:

✅ **Moderate to large number of partners** (3+)
- @Order coordination becomes overhead
- Configuration-driven approach preferred
- Scalability is priority

✅ **Flexible customization needed**
- Some partners need custom validation, others don't
- Want to add standard partners without code
- Custom partners only require validator bean

✅ **Operational simplicity preferred**
- Single filter to monitor
- Centralized metrics/logging with partner context
- Simpler deployment pipeline

✅ **Performance optimization matters**
- O(1) partner detection via x-partner-id
- No filter chain evaluation overhead
- No header prefix loop

✅ **Clean separation of concerns valued**
- Filter handles flow, validators handle logic
- Config contains data, validators contain rules
- Composition over inheritance preferred

---

## Recommendation for LND-4526

### Decision: Approach A Selected ✅

**Selected for initial implementation** based on limited blast radius analysis (1 partner, growing to 2-3 within 12 months).

**Key Decision Factors**:
1. **Strong Isolation**: Complete separation between partner filters minimizes cross-partner impact
2. **Defense-in-Depth Security**: Catch-all filter provides additional security layer
3. **Limited Scalability Needs**: 1-3 partners makes @Order management and code duplication acceptable
4. **Conservative Engineering**: Lower risk for initial implementation, migration path available if needed

**Trade-offs Accepted**:
- Manual @Order management (acceptable for <3 partners)
- Code duplication per partner (~10 lines per filter)
- Not configuration-driven (acceptable given small partner count)

### Original Analysis (For Reference):

#### Approach A Strengths (Selected):
1. Team values complete isolation and defense-in-depth ✅
2. Only 1-2 partners expected in near term ✅
3. Prefer familiar template method pattern ✅
4. Catch-all filter safety net is priority ✅

#### Approach B Strengths (Not Selected):
1. Expect 3+ partners within 6-12 months ❌
2. Want configuration-driven partner addition
3. Value O(1) partner detection efficiency
4. Prefer composition and validator pattern

### Migration Considerations:

**From A to B**:
- Feasible but requires refactoring
- Extract validation logic from filters to validators
- Update config to include partner-id
- Update clients to send x-partner-id header

**From B to A**:
- More complex migration
- Extract validators to filter classes
- Potentially disruptive client changes (remove x-partner-id)

---

## Implementation Plan

### Phase 1: Design Approval (Days 1-2)
- Senior engineering review of this RFC
- Resolve open questions (see below)
- Select Approach A or B based on priorities
- Document decision rationale

### Phase 2: Core Implementation (Days 3-10)
- **Approach A**: Base filter class → Partner-specific filters → Catch-all filter → Tests
- **Approach B**: Single filter → Validator interface → Partner validators → Tests

### Phase 3: Testing & Validation (Days 11-15)
- Unit and integration testing
- Integration testing with Veefin staging environment
- Documentation updates (API specs, runbooks)

### Phase 4: Deployment (Days 16-20)
- Deploy to dev → staging → production (gradual rollout)
- Monitor metrics for 24 hours post-rollout

**Estimated Total Duration**: 20 business days (4 weeks)

---

## Rollback Plan

Since this feature does not impact existing authentication mechanisms, rollback is configuration-based:

**Configuration-Based Rollback** (< 1 minute):
1. Change partner ID in configuration (e.g., `veefin` → `veefin-disabled`)
2. All signature authentication requests will fail with "Unknown partner" error
3. Existing non-signature authentication remains unaffected
4. No application restart required (config hot-reload)

**Rollback Triggers**:
- Signature verification failure rate >5%
- Authentication latency increase >100ms (P95)
- Partner integration errors blocking critical flows
- Security vulnerability discovered

---

## Testing Strategy

### Unit Testing
- Valid signature authentication (success path)
- Invalid signature rejection
- Expired timestamp rejection
- Missing/malformed headers rejection
- Path-based access control
- **Approach A**: Test each filter independently, test catch-all protection
- **Approach B**: Test single filter with different partners, test validator delegation

### Integration Testing
- End-to-end authentication flows with mock partner endpoints
- Signature generation and verification
- Multi-partner concurrent access scenarios
- Path protection validation

**Coverage Target**: >85% unit test coverage, 100% critical path integration coverage

---

## Security & Compliance

### Threat Model

**Threats Mitigated**:
- ✅ Unauthorized access (signature verification)
- ✅ Replay attacks (timestamp validation, 5-minute window)
- ✅ Man-in-the-Middle (HMAC-SHA256 integrity)
- ✅ Partner impersonation (partner-specific secrets)

**Residual Risks**:
- ⚠️ Replay within 5-minute window (mitigation: request-id deduplication for high-risk endpoints)
- ⚠️ Secret compromise (mitigation: quarterly rotation)
- ⚠️ Timestamp skew (mitigation: 5-minute tolerance)

### Compliance Considerations
- No PII in signature payload
- Secrets stored in environment variables or secrets manager
- Logs sanitized (no secrets)
- Audit trail for all authentication attempts
- Secret rotation procedure documented

---

## Performance Impact

### Latency Analysis
- Header extraction: ~0.1ms
- Config lookup: ~0.1ms
- HMAC-SHA256 computation: ~1-2ms
- Timestamp validation: ~0.05ms
- **Total**: ~1.5-2.5ms per request (P95)

### Throughput Impact
- Expected load: 100-300 req/s (Veefin + future partners)
- CPU: ~0.5% per 100 req/s (HMAC computation)
- Memory: <10 MB (config + filters)
- Stateless authentication scales linearly

---

## Monitoring & Observability

To be defined during implementation based on existing monitoring infrastructure.

---

## Appendix

### Appendix A: Code Volume Comparison

**Approach A (5 Partners)**:
- `AbstractPartnerSignatureFilter.java`: ~150 lines
- Per-partner filters (5 × 10 lines): ~50 lines
- `PartnerCatchAllFilter.java`: ~50 lines
- Supporting classes: ~130 lines
- **Total**: ~380 lines, 9 files

**Approach B (5 Partners, 2 custom validators)**:
- `PartnerSignatureAuthFilter.java`: ~150 lines
- `PartnerSignatureValidator.java` (interface): ~30 lines
- `DefaultSignatureValidator.java`: ~80 lines
- Custom validators (2 × 30 lines): ~60 lines
- Supporting classes: ~130 lines
- **Total**: ~450 lines, 7 files

**Scalability Note**:
- Approach B scales better: adding partners requires only YAML config (standard validation) or +1 validator class (~30 lines) for custom validation
- Approach A requires +1 filter class per partner regardless of customization needs

---

## Open Questions for Review

### Architecture Review:
1. ❓ Do partners have significantly different requirements?
2. ❓ What's the priority: isolation (A) vs. scalability (B)?

### Security Review:
1. ❓ Is neutral `x-partner-id` header acceptable for partner identification?
2. ❓ Is defense-in-depth (catch-all filter) required, or is single validation point sufficient?
3. ❓ Are partners comfortable with additional neutral header requirement?

### Operational Review:
1. ❓ Is validator pattern familiar to team, or prefer template method?

### Monitoring & Observability Review:
1. ❓ What metrics should be tracked for partner authentication?
2. ❓ What logging format and log levels are required?

---

## Appendix A: Code Volume Comparison

### Approach A (5 Partners):
- `AbstractPartnerSignatureFilter.java`: ~150 lines
- `VeefinSignatureAuthenticationFilter.java`: ~10 lines
- `PartnerBSignatureAuthenticationFilter.java`: ~10 lines
- `PartnerCSignatureAuthenticationFilter.java`: ~10 lines
- `PartnerDSignatureAuthenticationFilter.java`: ~10 lines
- `PartnerESignatureAuthenticationFilter.java`: ~10 lines
- `PartnerCatchAllFilter.java`: ~50 lines
- `SignatureUtils.java`: ~50 lines
- `PartnerSignatureConfig.java`: ~80 lines
- **Total**: ~380 lines, 9 files

### Approach B (5 Partners, 2 with custom validation):
- `PartnerSignatureAuthFilter.java`: ~150 lines (filter flow only)
- `PartnerSignatureValidator.java`: ~30 lines (interface)
- `DefaultSignatureValidator.java`: ~80 lines (default implementation)
- `VeefinSignatureValidator.java`: ~30 lines (custom validation)
- `PartnerBSignatureValidator.java`: ~30 lines (custom validation)
- `SignatureUtils.java`: ~50 lines
- `PartnerSignatureConfig.java`: ~80 lines
- **Total**: ~450 lines, 7 files

**Note**: Approach B has more lines initially but scales better:
- Adding partner with standard validation: 0 new files, 5 lines YAML
- Adding partner with custom validation: 1 validator file (~30 lines), 5 lines YAML

---

## Appendix B: Testing Strategy Comparison

### Approach A:
```java
// Test each filter independently
@Test
void testVeefinFilter_ValidSignature_Allows() { /* ... */ }

@Test
void testVeefinFilter_InvalidSignature_Rejects() { /* ... */ }

@Test
void testPartnerBFilter_ValidSignature_Allows() { /* ... */ }

// Integration test
@Test
void testMultipleFilters_DifferentPartners_BothWork() { /* ... */ }

// Catch-all filter tests
@Test
void testCatchAllFilter_UnauthenticatedProtectedPath_Rejects() {
    // Request to /fs/brick/service/veefin/** without valid signature
    // Should be rejected by catch-all with 401
}

@Test
void testCatchAllFilter_AuthenticatedProtectedPath_Allows() {
    // Request with valid signature sets partner.authenticated=true
    // Catch-all should allow through
}

@Test
void testCatchAllFilter_UnprotectedPath_Allows() {
    // Request to non-partner path
    // Catch-all should allow through regardless of authentication
}

@Test
void testCatchAllFilter_DynamicPatterns_UpdatesFromConfig() {
    // Verify catch-all collects patterns from all partners in YAML
}
```

### Approach B:
```java
// Test filter with neutral x-partner-id
@Test
void testFilter_ValidXPartnerIdHeader_IdentifiesPartner() {
    // Request with x-partner-id: veefin
    // Should lookup veefin config and use veefin-x-* headers
}

@Test
void testFilter_MissingXPartnerId_Rejects() {
    // Request without x-partner-id header
    // Should reject with 401
}

@Test
void testFilter_UnknownPartner_Rejects() {
    // Request with x-partner-id: unknown
    // Should reject with 401
}

// Test validator delegation
@Test
void testFilter_DelegatesToDefaultValidator() {
    // Partner without custom validator uses DefaultSignatureValidator
}

@Test
void testFilter_DelegatesToCustomValidator() {
    // Partner with custom validator uses VeefinSignatureValidator
}

// Test validators independently
@Test
void testVeefinValidator_HexRequestId_Accepts() {
    // Veefin custom validator accepts hex-only request-id
}

@Test
void testVeefinValidator_NonHexRequestId_Rejects() {
    // Veefin custom validator rejects non-hex request-id
}

@Test
void testDefaultValidator_StandardValidation() {
    // Default validator accepts alphanumeric request-id
}

// Integration tests
@ParameterizedTest
@ValueSource(strings = {"veefin", "partner-b", "partner-c"})
void testFilter_AllPartners_WithXPartnerId(String partnerId) {
    // Test all partners with x-partner-id header
}
```
